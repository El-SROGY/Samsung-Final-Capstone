# -*- coding: utf-8 -*-
"""x_ray_API.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h4O0g4BMjXi-OBVaRK58xDvEKWV_oVGS
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
from pathlib import Path as path
# %matplotlib inline
import imblearn
from imblearn.under_sampling import RandomUnderSampler
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications.mobilenet_v2 import preprocess_input
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, Flatten, Dropout, BatchNormalization
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.preprocessing import image


def proc_img(filepath):
    """ Create a DataFrame with the filepath and the labels of the pictures
    """
    labels = list(map(lambda x: os.path.split(
        os.path.split(x)[0])[1], filepath))

    filepath = pd.Series(filepath, name='Filepath').astype(str)
    labels = pd.Series(labels, name='Label')

    # Concatenate filepaths and labels
    df = pd.concat([filepath, labels], axis=1)

    # Shuffle the DataFrame and reset index
    df = df.sample(frac=1).reset_index(drop=True)
    return df


# Early stop
early_stop = EarlyStopping(
    monitor='val_loss', patience=2, restore_best_weights=True)


class COVID19_Classification:

    # to check the training of the model
    is_trained = False

    def get_data(self):
        # COVID data
        covid_path = path(r"D:\BFCAI\Samsung\Project\train (1)\COVID19")
        covid_images = os.listdir(covid_path)
        covid_filepaths = [str(covid_path) + '/' +
                           img_path for img_path in covid_images]
        # Normal data
        normal_path = path(r"D:\BFCAI\Samsung\Project\train (1)\NORMAL")
        normal_images = os.listdir(normal_path)
        normal_filespaths = [str(normal_path) + '/' +
                             img_path for img_path in normal_images]
        covid_df = proc_img(covid_filepaths)
        normal_df = proc_img(normal_filespaths)
        df = pd.concat([covid_df, normal_df], axis=0)
        # Im_Balanced Data
        undersample = RandomUnderSampler(sampling_strategy='majority')
        X = df.iloc[:, :1].values
        y = df.iloc[:, 1]
        X, y = undersample.fit_resample(X, y)
        X = X.reshape((920, ))
        balanced_df = pd.DataFrame({'Filepath': X, 'Label': y})
        # Test_df
        self.test_df = balanced_df.sample(n=184, random_state=42)
        self.train_df = balanced_df.merge(
            self.test_df, how='outer', indicator=True).loc[lambda x: x['_merge'] == 'left_only']

    def preprocess(self):
        self.get_data()
        # Train generator
        train_generator = ImageDataGenerator(
            preprocessing_function=preprocess_input,
            rescale=1./255
        )

        self.train_images = train_generator.flow_from_dataframe(
            dataframe=self.train_df,
            x_col='Filepath',
            y_col='Label',
            target_size=(255, 255),
            color_mode='rgb',
            class_mode='categorical',
            batch_size=32,
            shuffle=True,
            seed=0,
            subset='training',
            rotation_range=30,
            zoom_range=0.15,
            width_shift_range=0.2,
            height_shift_range=0.2,
            shear_range=0.15,
            horizontal_flip=True,
            fill_mode="nearest"
        )
        # Test generator
        test_generator = ImageDataGenerator(
            preprocessing_function=preprocess_input,
            rescale=1./255
        )

        self.test_images = test_generator.flow_from_dataframe(
            dataframe=self.test_df,
            x_col='Filepath',
            y_col='Label',
            target_size=(255, 255),
            color_mode='rgb',
            class_mode='categorical',
            batch_size=32,
            shuffle=True,
            seed=0,
            subset='training',
            rotation_range=30,
            zoom_range=0.15,
            width_shift_range=0.2,
            height_shift_range=0.2,
            shear_range=0.15,
            horizontal_flip=True,
            fill_mode="nearest"
        )

    def train(self):
        self.preprocess()
        self.model = Sequential()

        self.model.add(Conv2D(kernel_size=(3, 3), filters=32,
                       activation='relu', input_shape=(255, 255, 3,)))
        self.model.add(
            Conv2D(filters=30, kernel_size=(3, 3), activation='relu'))

        self.model.add(MaxPool2D(2, 2))
        self.model.add(
            Conv2D(filters=32, kernel_size=(3, 3), activation='relu'))

        self.model.add(MaxPool2D(2, 2))
        self.model.add(
            Conv2D(filters=32, kernel_size=(3, 3), activation='relu'))

        self.model.add(Flatten())

        self.model.add(Dense(128, activation='relu'))
        self.model.add(Dense(64, activation='relu'))
        self.model.add(Dense(32, activation='relu'))
        self.model.add(Dense(2, activation='softmax'))  # the output layer

        self.model.compile(loss='categorical_crossentropy',
                           optimizer='adam', metrics=['accuracy'])

        self.model.fit(self.train_images, epochs=25,
                       validation_data=self.test_images, verbose=1, callbacks=early_stop)

        print("Training done !")

    def predict(self):
        # check if the model was trained before
        if self.is_trained == False:
            self.train()
            # Predict the label of the test_images
            pred = self.model.predict(self.test_images)
            pred = np.argmax(pred, axis=1)
            # Map the label
            labels = (self.train_images.class_indices)
            labels = dict((v, k) for k, v in labels.items())
            pred = [labels[k] for k in pred]
            self.is_trained = True
        # for i in range(5):
        #     indexs = []
        #     indexs.append(np.random.randint(low=0, high=180, size=1))

            x = []
            for i in range(5):
                x.append(
                    f"True: {self.test_df.Label.iloc[i].split('_')[0]} Predicted: {pred[i].split('_')[0]}")
            return x

    def predict_path(self, path):
        img = image.load_img(path, target_size=(255, 255))
        img_array = image.img_to_array(img)
        img_batch = np.expand_dims(img_array, axis=0)
        img_preprocessed = img_batch / 255.0
        pred = self.model.predict(img_preprocessed)
        pred = np.argmax(pred, axis=1)
        if pred == 0:
            pred = 'covid'
        else:
            pred = 'normal'
        x = f"the predicted value: {pred}"
        return x
